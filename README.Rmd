---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# arcgislayers

<!-- badges: start -->

[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)
[![License](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
[![R-CMD-check](https://github.com/R-ArcGIS/arcgislayers/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/R-ArcGIS/arcgislayers/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

The goal of `{arcgislayers}` is to provide an R interface to the [ArcGIS REST API](https://developers.arcgis.com/rest/) .

## Installation

arcgislayers requires `{arcgisutils}` for authorization. It is recommend you install and use the metapackage `{arcgis}`. You can install the development version of arcgis like so:

``` r
remotes::install_github("r-arcgis/arcgis", dependencies = TRUE)
```

## Usage

### Creating a simple feature object from an ArcGIS FeatureLayer

```{r}
library(arcgis)
```

`arc_open()` takes a URL to create a reference to a remote ArcGIS layer, server, or table. The function can return any of the following classes (corresponding to different ArcGIS service types):

  - `FeatureLayer`
  - `Table`
  - `FeatureServer`
  - `ImageServer`
  - `MapServer`
  - `GroupLayer`
  
For example, you can create a `FeatureLayer` object based on a Feature Server URL:
  
```{r}
furl <- "https://services.arcgis.com/P3ePLMYs2RVChkJx/ArcGIS/rest/services/USA_Counties_Generalized_Boundaries/FeatureServer/0"

county_fl <- arc_open(furl)

county_fl
```

You can then use `arc_select()` to query the feature layer object and return an `sf` object.

If no arguments are provided to `arc_select()` the entire feature layer is returned in memory as an `sf` object. 

```{r}
arc_select(county_fl)
```
### Filtering using `where` or `filter_geom` arguments 

You can also use the `fields` argument to subset columns or `where` argument to subset rows.

For example, using a character vector of column names for `fields` and a simple SQL where clause for  `where` you can select counties with population greater than 1,000,000:

```{r}
arc_select(
  county_fl, 
  fields = c("state_abbr", "population"), 
  where = "population > 1000000"
)
```

For `FeatureLayer` and `Table` objects, the `list_fields()` function can be helpful to check available attributes and build a `where` query:

```{r}
list_fields(county_fl)
```

You can also provide a `bbox`, `sfc`, or `sfg` object to the `filter_geom` argument to perform a spatial filter. If the `sfc` object contains more than one geometry, the object is combined with `sf::st_union()`. See documentation for more (`?arc_select`).

```{r}
nc <- sf::st_read(system.file("shape/nc.shp", package="sf"))

arc_select(
  county_fl,
  filter_geom = sf::st_bbox(nc[1,])
)
```

### Creating a `SpatRaster` from an ArcGIS ImageServer

A `SpatRaster` object from the `{terra}` package can be extracted from an `ImageServer` using `arc_raster()`.

`arc_raster()` requires a `bbox` class object from the `sf` package to define the area to be extracted. You can optionally specify the `width` and `height` of the resultant image. Use `format` to define what type of image is returned.

```{r}
img_url <- "https://landsat2.arcgis.com/arcgis/rest/services/Landsat/MS/ImageServer"

landsat <- arc_open(img_url)

res <- arc_raster(
  landsat, 
  xmin = -71, ymin = 43, 
  xmax = -67, ymax = 47.5, 
  bbox_crs = 4326, 
  width = 500, height = 500
)

terra::plotRGB(res, 4, 3, 2, scale = max(landsat[["maxValues"]]))
```

## Authorization and publication

### Authorization for non-public data access

Authorization is required for users who wish to access data that is in a non-public ArGIS Online (AGOL) organization, in an ArcGIS Enterprise portal, or wish to upload data to or modify data in AGOL.

For more information on code based authorization using the `auth_code()` function or client authorization using `auth_client()` see the `{arcgislayers}` [authorization article](articles/Authorization.html).

### Publishing data from R

The package includes functions to publish data to an ArcGIS Portal:

- `add_item()`: Creates a new FeatureCollection from a `sf` or `data.frame` object
- `publish_item()`: Publishes an existing FeatureLayer
- `publish_layer()`: is a higher level wrapper around both `add_item()` and `publish_item()`

There are also functions to add or modify data including `add_features()`, `update_features()`, and `delete_features()`. For a more detailed guide to adding, updating, and deleting features, view the tutorial on the [R-ArcGIS Bridge website](https://r.esri.com/r-bridge-site/location-services/workflows/add-delete-update.html).

<!-- # DEPRECATED FROM HERE DOWN  -->

<!-- TODO update and rewrite -->

<!-- ## Feature Layers -->

<!-- Read in data from a feature layer. arcgis implements a `FeatureLayer` class object which is used to control how we read data from a Feature Layer service.  -->

<!-- Create a `FeatureLayer` with `feature_layer()` which takes the url of the feature layer as its only argument.  -->

<!-- ```{r example} -->
<!-- library(arcgis) -->

<!-- # define the feature layer url -->
<!-- furl <- "https://services.arcgis.com/P3ePLMYs2RVChkJx/ArcGIS/rest/services/USA_Counties_Generalized_Boundaries/FeatureServer/0" -->

<!-- # create a feature layer -->
<!-- county_fl <- feature_layer(furl) -->

<!-- county_fl -->
<!-- ``` -->

<!-- `FeatureLayer` objects are lists that contain metadata from the FeatureServer. The data that is used to create the `FeatureLayer` is taken directly from the url when displayed in json format. `FeatureLayer`s are intended to work somewhat similarly to a lazy table where data is only brought into memory when explicitly requested.  -->

<!-- The `collect_layer()` function will fetch all data for a layer from the REST endpoint and write it to the appropriate typeâ€”either an sf object or a data frame.  -->

<!-- ```{r cars} -->
<!-- county_sf <- collect_layer(county_fl) -->

<!-- county_sf -->
<!-- ``` -->

<!-- We can check to see what fields and types are present in our feature layer using `list_fields()`.  -->

<!-- ```{r} -->
<!-- list_fields(county_fl) -->
<!-- ``` -->

<!-- You can provide a more detailed query to the layer using `query_layer()`.  -->


<!-- ```{r} -->
<!-- res <- query_layer( -->
<!--   county_fl,  -->
<!--   where = "STATE_NAME = 'California' and POPULATION >= 30000", -->
<!--   fields = c("FIPS", "STATE_NAME", "SQMI", "POPULATION") -->
<!-- ) -->

<!-- res -->
<!-- ``` -->

<!-- Additionally, you can provide sf objects as spatial filters based on a predicate function.  Possible options are "intersects", "contains", "crosses", "overlaps", "touches", and "within". -->

<!-- In this example we create a polygon representing the bounding box of the West Coast of the US to act as our spatial filter.  -->

<!-- ```{r} -->
<!-- west_coast_bbox <- sf::st_as_sfc( -->
<!--   sf::st_bbox(c(xmin = -125, ymin = 32, xmax = -114, ymax = 49)) -->
<!-- ) -->

<!-- west_coast_bbox -->
<!-- ``` -->

<!-- We can then provide it as input to the `filter_geom` argument to act as a spatial filter.  -->

<!-- ```{r} -->
<!-- res <- query_layer( -->
<!--   county_fl,  -->
<!--   filter_geom = west_coast_bbox -->
<!-- ) -->

<!-- plot(res$geometry) -->
<!-- plot(west_coast_bbox, lty = 3, add = TRUE) -->
<!-- ``` -->

<!-- For manual control of the parameters that will be sent to the REST API you can use `update_params()`. This function allows you to built up your query iteratively and programmatically without executing the query right away. Use it in conjunction with `collect_layer()` for a lazy-ish process. -->

<!-- ```{r} -->
<!-- fl_query <- update_params( -->
<!--   county_fl,  -->
<!--   where = "STATE_NAME = 'New Hampshire'", -->
<!--   outFields = "STATE_NAME,POPULATION" -->
<!-- ) -->

<!-- fl_query -->
<!-- ``` -->

<!-- Notice the appended query. You can execute the query and bring the results into memory using `collect_layer()`. -->

<!-- ```{r} -->
<!-- collect_layer(fl_query) -->
<!-- ``` -->

<!-- ## Interfacing with `{arcgisbinding}` -->


<!-- - to do.... -->


<!-- ### dplyr-like syntax -->

<!-- You may not need all of these fields or features in your R session. If that's the case, it is more effective to bring in only a subset of the data that you need. We can limit what is brought into memory by using `select()` and `filter()` functions to build up a query that can be sent the rest API.  -->

<!-- The `select()` `FeatureLayer` method supports using `{tidyselect}` functions except the `where()` function. -->

<!-- ```{r} -->
<!-- county_fl |>  -->
<!--   select(contains("STATE")) -->
<!-- ``` -->

<!-- Now that we've ran `select()` on the `FeatureLayer` query parameters are printed out. The parameters will be sent along when the results are `collect()`ed.  -->

<!-- You can further subset your data by using `filter()`. Note that filtering is fairly limited ([see API documentation for more](https://developers.arcgis.com/rest/services-reference/enterprise/query-feature-service-layer-.htm#GUID-BC2AD141-3386-49FB-AA09-FF341145F614)). -->

<!-- ```{r} -->
<!-- county_query <- county_fl |>  -->
<!--   select(starts_with("STATE")) |>  -->
<!--   filter(STATE_NAME == "Alabama") -->

<!-- county_query -->
<!-- ``` -->

<!-- Bring it into memory with `collect()`. -->

<!-- ```{r} -->
<!-- res <- collect(county_query) -->
<!-- res -->
<!-- ``` -->


<!-- ### Other `FeatureLayer` functions -->

<!-- You can add any parameter that you'd like that is supported by the query parameters [listed in the documentation](https://developers.arcgis.com/rest/services-reference/enterprise/query-feature-service-layer-.htm#GUID-BC2AD141-3386-49FB-AA09-FF341145F614) with the using the `update_params()` function. -->


<!-- ```{r} -->
<!-- county_query |>  -->
<!--   update_params(returnIdsOnly = "true") |>  -->
<!--   collect() -->
<!-- ``` -->

<!-- Maybe, you want to clear our your query parameters, use `clear_query()`. -->

<!-- ```{r} -->
<!-- clear_query(county_query) -->
<!-- ``` -->

<!-- To preview only a few features from the feature layer use `head()` -->

<!-- ```{r} -->
<!-- head(county_query) -->
<!-- ``` -->


<!-- ## `FeatureServers` -->


<!-- FeatureServers contain one or more `FeatureLayers` or `Tables`.  -->

<!-- ```{r} -->
<!-- ft_srv <- feature_server( -->
<!--   "https://services2.arcgis.com/j80Jz20at6Bi0thr/ArcGIS/rest/services/List_of_Providers/FeatureServer/" -->
<!--   ) -->

<!-- ft_srv -->
<!-- ``` -->

<!-- Access elements by ID with `get_layer()` -->

<!-- ```{r} -->
<!-- get_layer(ft_srv, 27) -->
<!-- ``` -->

<!-- Get a list of all elements. -->

<!-- ```{r} -->
<!-- get_all_layers(ft_srv) -->
<!-- ``` -->

<!-- ## Conversion to Esri JSON -->


<!-- sf objects can be converted to Esri JSON representation. These can be Geometry Objects, FeatureSets, or arrays of Features.  -->

<!-- `st_as_geometry()` works with objects of class `sfg` and creates a Geometry Object. `st_as_featureset()` creates a FeatureSet from an sf or sfc object. sfc objects will have 0 length attributes. `st_as_features()` works with an sf or sfc object.  -->


<!-- ```{r} -->
<!-- st_as_geometry(res[["geometry"]][[30]]) |>  -->
<!--   # print nicely with jsonify -->
<!--   jsonify::pretty_json() -->
<!-- ``` -->

<!-- ```{r} -->
<!-- st_as_featureset(res[30,]) |>  -->
<!--   jsonify::pretty_json() -->
<!-- ``` -->
